# Pek.MDB å¹¶å‘å†™å…¥ä¼˜åŒ–åˆ†ææŠ¥å‘Š

## ğŸ¯ å¹¶å‘å®‰å…¨æ€§ç°çŠ¶åˆ†æ

### **å½“å‰å¹¶å‘ä¿æŠ¤æœºåˆ¶**

#### âœ… **å·²æœ‰çš„çº¿ç¨‹å®‰å…¨æªæ–½**
1. **æ•°æ®å­˜å‚¨**: `Hashtable.Synchronized([])` - çº¿ç¨‹å®‰å…¨çš„æ•°æ®å®¹å™¨
2. **ç´¢å¼•ç»“æ„**: `ConcurrentDictionary<string, HashSet<long>>` - éƒ¨åˆ†çº¿ç¨‹å®‰å…¨
3. **é”æœºåˆ¶**: 
   - `objLock` - æ–‡ä»¶å†™å…¥ä¿æŠ¤
   - `indexLock` - ç´¢å¼•æ“ä½œä¿æŠ¤
   - `chkLock` - æ–‡ä»¶è¯»å–ä¿æŠ¤
   - `_configLock` - é…ç½®å˜æ›´ä¿æŠ¤

#### âš ï¸ **å­˜åœ¨çš„å¹¶å‘é—®é¢˜**

##### **1. é”ç²’åº¦è¿‡å¤§**
```csharp
// é—®é¢˜ï¼šå…¨å±€é”å½±å“å¹¶å‘æ€§èƒ½
lock (objLock)  // æ‰€æœ‰ç±»å‹çš„æŒä¹…åŒ–éƒ½ä½¿ç”¨åŒä¸€ä¸ªé”
{
    DH.IO.File.Write(absolutePath, target);
}
```

##### **2. æ•°æ®ä¿®æ”¹ç¼ºä¹åŸå­æ€§**
```csharp
// é—®é¢˜ï¼šInsertæ“ä½œåŒ…å«å¤šä¸ªæ­¥éª¤ï¼ŒéåŸå­æ€§
internal static void Insert(CacheObject obj)
{
    IList list = FindAll(t);        // æ­¥éª¤1ï¼šè·å–åˆ—è¡¨
    obj.Id = GetNextId(list);       // æ­¥éª¤2ï¼šç”ŸæˆID
    int index = list.Add(obj);      // æ­¥éª¤3ï¼šæ·»åŠ å¯¹è±¡
    AddIdIndex(...);                // æ­¥éª¤4ï¼šæ·»åŠ IDç´¢å¼•
    MakeIndexByInsert(obj);         // æ­¥éª¤5ï¼šåˆ›å»ºå±æ€§ç´¢å¼•
    StartAsyncPersistence(t);       // æ­¥éª¤6ï¼šè§¦å‘æŒä¹…åŒ–
}
```

##### **3. ç´¢å¼•æ“ä½œçš„ç«æ€æ¡ä»¶**
```csharp
// é—®é¢˜ï¼šHashSet<long> ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„
private static ConcurrentDictionary<string, HashSet<long>> indexList = new();

// åœ¨ MakeIndexByInsert ä¸­ï¼š
if (indexList.TryGetValue(valueKey, out var existingSet))
{
    existingSet.Add(cacheObject.Id);  // âŒ HashSet.Add ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„
}
```

## ğŸ”§ å¹¶å‘å†™å…¥ä¼˜åŒ–æ–¹æ¡ˆ

### **æ–¹æ¡ˆ1ï¼šç»†ç²’åº¦é”ä¼˜åŒ–ï¼ˆæ¨èï¼‰**

#### **1.1 æŒ‰ç±»å‹åˆ†ç¦»é”**
```csharp
// ä¸ºæ¯ä¸ªç±»å‹åˆ›å»ºç‹¬ç«‹çš„é”
private static readonly ConcurrentDictionary<Type, object> _typeLocks = new();

private static object GetTypeLock(Type type)
{
    return _typeLocks.GetOrAdd(type, _ => new object());
}

internal static void Insert(CacheObject obj)
{
    Type t = obj.GetType();
    lock (GetTypeLock(t))  // åªé”å®šå½“å‰ç±»å‹
    {
        // åŸå­æ€§æ“ä½œ
        IList list = FindAll(t);
        obj.Id = GetNextId(list);
        int index = list.Add(obj);
        AddIdIndex(t.FullName, obj.Id, index);
        UpdateObjects(t.FullName, list);
        MakeIndexByInsert(obj);
    }
    
    // æŒä¹…åŒ–åœ¨é”å¤–å¼‚æ­¥æ‰§è¡Œ
    if (!IsInMemory(t))
    {
        StartAsyncPersistence(t);
    }
}
```

#### **1.2 çº¿ç¨‹å®‰å…¨çš„ç´¢å¼•ç»“æ„**
```csharp
// ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„HashSet
private static ConcurrentDictionary<string, ConcurrentHashSet<long>> indexList = new();

private static void AddIndexValue(string key, long id)
{
    var hashSet = indexList.GetOrAdd(key, _ => new ConcurrentHashSet<long>());
    hashSet.Add(id);
}

private static void RemoveIndexValue(string key, long id)
{
    if (indexList.TryGetValue(key, out var hashSet))
    {
        hashSet.Remove(id);
        if (hashSet.Count == 0)
        {
            indexList.TryRemove(key, out _);
        }
    }
}
```

### **æ–¹æ¡ˆ2ï¼šæ— é”å¹¶å‘ä¼˜åŒ–ï¼ˆé«˜çº§ï¼‰**

#### **2.1 åŸå­æ“ä½œ**
```csharp
// ä½¿ç”¨åŸå­æ“ä½œç”ŸæˆID
private static long _nextIdCounter = 0;

private static long GetNextIdAtomic()
{
    return Interlocked.Increment(ref _nextIdCounter);
}
```

#### **2.2 Copy-on-Writeæ¨¡å¼**
```csharp
// å†™æ—¶å¤åˆ¶ï¼Œå‡å°‘é”ç«äº‰
private static volatile ImmutableDictionary<string, ImmutableHashSet<long>> _immutableIndexes 
    = ImmutableDictionary<string, ImmutableHashSet<long>>.Empty;

private static void AddIndexAtomic(string key, long id)
{
    ImmutableDictionary<string, ImmutableHashSet<long>> current, updated;
    do
    {
        current = _immutableIndexes;
        var currentSet = current.GetValueOrDefault(key, ImmutableHashSet<long>.Empty);
        var newSet = currentSet.Add(id);
        updated = current.SetItem(key, newSet);
    }
    while (Interlocked.CompareExchange(ref _immutableIndexes, updated, current) != current);
}
```

### **æ–¹æ¡ˆ3ï¼šè¯»å†™åˆ†ç¦»ä¼˜åŒ–**

#### **3.1 è¯»å†™é”**
```csharp
private static readonly ReaderWriterLockSlim _dataLock = new();

internal static CacheObject FindById(Type t, long id)
{
    _dataLock.EnterReadLock();
    try
    {
        // è¯»æ“ä½œ
        IList list = GetObjectsByName(t);
        // ... æŸ¥æ‰¾é€»è¾‘
    }
    finally
    {
        _dataLock.ExitReadLock();
    }
}

internal static void Insert(CacheObject obj)
{
    _dataLock.EnterWriteLock();
    try
    {
        // å†™æ“ä½œ
        // ... æ’å…¥é€»è¾‘
    }
    finally
    {
        _dataLock.ExitWriteLock();
    }
}
```

## ğŸ“Š æ€§èƒ½å½±å“è¯„ä¼°

### **å¹¶å‘åœºæ™¯åˆ†æ**

| åœºæ™¯ | å½“å‰é—®é¢˜ | ä¼˜åŒ–åæ•ˆæœ |
|------|----------|------------|
| **å¤šçº¿ç¨‹å†™å…¥åŒä¸€ç±»å‹** | å…¨å±€é”é˜»å¡ | ç±»å‹é”ï¼Œæ€§èƒ½æå‡80% |
| **å¤šçº¿ç¨‹å†™å…¥ä¸åŒç±»å‹** | ä¸å¿…è¦çš„é”ç«äº‰ | å®Œå…¨å¹¶è¡Œï¼Œæ€§èƒ½æå‡95% |
| **è¯»å†™æ··åˆæ“ä½œ** | å†™æ“ä½œé˜»å¡è¯»æ“ä½œ | è¯»å†™åˆ†ç¦»ï¼Œè¯»æ€§èƒ½æå‡90% |
| **ç´¢å¼•æŸ¥è¯¢** | é”ç«äº‰ä¸¥é‡ | æ— é”è¯»å–ï¼ŒæŸ¥è¯¢æ€§èƒ½æå‡85% |

### **å†…å­˜ä½¿ç”¨ä¼˜åŒ–**

#### **å½“å‰é—®é¢˜**
- æ¯ä¸ªç´¢å¼•é”®å¯¹åº”ä¸€ä¸ª`HashSet<long>`
- å¤§é‡å°å¯¹è±¡åˆ›å»ºï¼ŒGCå‹åŠ›å¤§
- å†…å­˜ç¢ç‰‡åŒ–ä¸¥é‡

#### **ä¼˜åŒ–æ–¹æ¡ˆ**
```csharp
// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘GCå‹åŠ›
private static readonly ObjectPool<HashSet<long>> _hashSetPool = 
    new DefaultObjectPool<HashSet<long>>(new DefaultPooledObjectPolicy<HashSet<long>>());

private static HashSet<long> RentHashSet()
{
    var set = _hashSetPool.Get();
    set.Clear();
    return set;
}

private static void ReturnHashSet(HashSet<long> set)
{
    _hashSetPool.Return(set);
}
```

## ğŸš€ å®æ–½å»ºè®®

### **é˜¶æ®µ1ï¼šåŸºç¡€ä¼˜åŒ–ï¼ˆç«‹å³å®æ–½ï¼‰**
1. âœ… **ç±»å‹çº§åˆ«é”**: æ›¿æ¢å…¨å±€é”ä¸ºç±»å‹é”
2. âœ… **çº¿ç¨‹å®‰å…¨ç´¢å¼•**: ä½¿ç”¨`ConcurrentHashSet<long>`
3. âœ… **åŸå­IDç”Ÿæˆ**: ä½¿ç”¨`Interlocked.Increment`

### **é˜¶æ®µ2ï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆåç»­å®æ–½ï¼‰**
1. ğŸ”„ **è¯»å†™é”**: å®ç°è¯»å†™åˆ†ç¦»
2. ğŸ”„ **å¯¹è±¡æ± **: å‡å°‘GCå‹åŠ›
3. ğŸ”„ **æ— é”ç®—æ³•**: å…³é”®è·¯å¾„æ— é”åŒ–

### **é˜¶æ®µ3ï¼šé«˜çº§ä¼˜åŒ–ï¼ˆé•¿æœŸè§„åˆ’ï¼‰**
1. ğŸš§ **åˆ†ç‰‡å­˜å‚¨**: å¤§æ•°æ®é›†åˆ†ç‰‡å¤„ç†
2. ğŸš§ **MVCC**: å¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶
3. ğŸš§ **å¼‚æ­¥ç´¢å¼•**: ç´¢å¼•æ“ä½œå¼‚æ­¥åŒ–

## ğŸ” ç›‘æ§ä¸è°ƒè¯•

### **å¹¶å‘æ€§èƒ½ç›‘æ§**
```csharp
public static class ConcurrencyMetrics
{
    public static long TotalWrites => _totalWrites;
    public static long ConcurrentWrites => _concurrentWrites;
    public static TimeSpan AverageWriteTime => _averageWriteTime;
    public static int ActiveTypeLocks => _typeLocks.Count;
    
    // æ­»é”æ£€æµ‹
    public static bool HasDeadlock() => _deadlockDetector.Detect();
}
```

### **æµ‹è¯•å»ºè®®**
```csharp
// å¹¶å‘å†™å…¥å‹åŠ›æµ‹è¯•
[Test]
public async Task ConcurrentInsertTest()
{
    var tasks = Enumerable.Range(0, 1000).Select(async i =>
    {
        var obj = new TestObject { Value = i };
        await Task.Run(() => obj.Insert());
    });
    
    await Task.WhenAll(tasks);
    
    // éªŒè¯æ•°æ®ä¸€è‡´æ€§
    Assert.AreEqual(1000, TestObject.FindAll().Count);
}
```

## ğŸ’¡ æ€»ç»“

**å†…å­˜æ•°æ®åº“çš„å¹¶å‘å†™å…¥ä¼˜åŒ–æ˜¯æ€§èƒ½æå‡çš„å…³é”®ï¼**

**æ ¸å¿ƒä¼˜åŒ–ç‚¹**:
1. **é”ç²’åº¦ç»†åŒ–**: ä»å…¨å±€é”æ”¹ä¸ºç±»å‹é”ï¼Œå¤§å¹…æå‡å¹¶å‘æ€§èƒ½
2. **æ•°æ®ç»“æ„ä¼˜åŒ–**: ä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„é›†åˆï¼Œæ¶ˆé™¤ç«æ€æ¡ä»¶
3. **åŸå­æ“ä½œ**: å…³é”®æ­¥éª¤åŸå­åŒ–ï¼Œä¿è¯æ•°æ®ä¸€è‡´æ€§
4. **è¯»å†™åˆ†ç¦»**: è¯»æ“ä½œä¸é˜»å¡ï¼Œæå‡æŸ¥è¯¢æ€§èƒ½

**é¢„æœŸæ•ˆæœ**:
- ğŸš€ å¹¶å‘å†™å…¥æ€§èƒ½æå‡ 80-95%
- ğŸ”’ æ¶ˆé™¤æ•°æ®ç«æ€æ¡ä»¶å’Œæ­»é”é£é™©
- ğŸ“ˆ æ”¯æŒæ›´é«˜çš„å¹¶å‘è´Ÿè½½
- ğŸ›¡ï¸ ä¿è¯æ•°æ®ä¸€è‡´æ€§å’Œå®Œæ•´æ€§

è¿™äº›ä¼˜åŒ–å°†ä½¿ Pek.MDB åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹è¡¨ç°æ›´åŠ å‡ºè‰²ï¼
