# 数据类型感知索引使用说明

## 概述

Pek.MDB 现已支持数据类型感知索引系统，这是对原有字符串索引的重大升级。新系统能够：

- **保持数据类型信息** - 不再将所有值转换为字符串
- **支持范围查询** - 数值和日期类型支持高效的范围查询
- **支持模糊查询** - 字符串类型支持通配符和模式匹配
- **提供查询优化** - 根据数据类型选择最优的查询策略
- **完全向后兼容** - 现有代码无需修改，自动获得性能提升

## 核心特性

### 1. 类型感知索引

系统会根据属性的数据类型自动选择合适的索引实现：

| 数据类型 | 索引类型 | 支持功能 |
|---------|---------|----------|
| `string` | StringIndex | 精确匹配、模糊查询、前缀/后缀匹配 |
| `int`, `long`, `decimal`, `float`, `double` | NumericIndex | 精确匹配、范围查询 |
| `DateTime`, `DateTimeOffset` | DateTimeIndex | 精确匹配、时间范围查询、年月日查询 |
| `bool` | BooleanIndex | 精确匹配、多种布尔值表示 |
| 其他类型 | GenericIndex | 精确匹配、通用范围查询 |

### 2. 新增查询方法

```csharp
// 范围查询
var products = cdb.FindByRange<Product>("Price", 1000m, 5000m);
var recentOrders = cdb.FindByDateRange<Order>("CreateTime", DateTime.Today.AddDays(-7), DateTime.Today);

// 模糊查询（支持通配符）
var results = cdb.FindByLike<Product>("Name", "手机*");  // 以"手机"开头
var results = cdb.FindByLike<Product>("Name", "*Pro");   // 以"Pro"结尾
var results = cdb.FindByLike<Product>("Tags", "*苹果*"); // 包含"苹果"

// 便捷查询方法
var results = cdb.FindByContains<Product>("Name", "苹果");     // 包含查询
var results = cdb.FindByStartsWith<Product>("Code", "APL");   // 前缀查询
var results = cdb.FindByEndsWith<Product>("Name", "Pro");     // 后缀查询

// 复合条件查询
var conditions = new Dictionary<string, object>
{
    { "CategoryId", 1 },
    { "IsActive", true }
};
var results = cdb.FindByMultiple<Product>(conditions);

// 分页查询
var pagedResult = cdb.FindByPage<Product>("Price", pageIndex: 0, pageSize: 10, ascending: true);

// 批量ID查询
var productMap = cdb.FindByIds<Product>(new long[] { 1, 2, 3, 4, 5 });
```

### 3. 索引管理和监控

```csharp
// 获取索引统计信息
var stats = IndexManager.GetIndexStats(typeof(Product), "Price");
Console.WriteLine($"查询次数: {stats.QueryCount}, 命中率: {stats.HitRate:P}");

// 获取所有索引统计
var allStats = IndexManager.GetAllIndexStats();

// 获取优化建议
var recommendations = IndexManager.RecommendIndexOptimization();
foreach (var rec in recommendations)
{
    Console.WriteLine($"{rec.PropertyName}: {rec.Recommendation}");
}

// 验证索引完整性
var report = IndexManager.ValidateIndexIntegrity();
Console.WriteLine($"索引健康: {report.IsHealthy}");

// 生成性能报告
var performanceReport = IndexManager.GeneratePerformanceReport();
Console.WriteLine(performanceReport);
```

## 配置选项

### 启用/禁用类型感知索引

```csharp
// 启用类型感知索引（默认启用）
cdb.EnableTypedIndex(true);

// 禁用类型感知索引（降级到传统字符串索引）
cdb.EnableTypedIndex(false);

// 检查状态
bool isEnabled = cdb.IsTypedIndexEnabled();
```

### 属性标记

继续使用现有的索引标记系统：

```csharp
public class Product : CacheObject
{
    [Indexed("主要查询字段")]
    public string Name { get; set; }           // 字符串索引

    [Indexed("价格范围查询")]
    public decimal Price { get; set; }         // 数值索引

    [Indexed("时间查询")]
    public DateTime CreateTime { get; set; }   // 日期时间索引

    [NotIndexed("大文本字段")]
    public string Description { get; set; }    // 不建立索引

    [NotSave]
    public decimal CachedValue { get; set; }   // 不保存
}
```

## 使用示例

### 基本查询示例

```csharp
public class QueryExamples
{
    public static void RunExamples()
    {
        // 1. 数值范围查询
        var expensiveProducts = cdb.FindByRange<Product>("Price", 5000m, 10000m);
        
        // 2. 时间范围查询
        var lastWeekOrders = cdb.FindByDateRange<Order>("CreateTime", 
            DateTime.Today.AddDays(-7), DateTime.Today);
        
        // 3. 字符串模糊查询
        var appleProducts = cdb.FindByLike<Product>("Name", "*Apple*");
        
        // 4. 复合查询
        var activeExpensiveProducts = cdb.FindByMultiple<Product>(new Dictionary<string, object>
        {
            { "IsActive", true },
            { "CategoryId", 1 }
        }).Where(p => p.Price > 1000m).ToList();
        
        // 5. 分页查询
        var page1 = cdb.FindByPage<Product>("Name", 0, 20, true);
        Console.WriteLine($"第1页，共{page1.TotalPages}页，总计{page1.TotalCount}条");
    }
}
```

### 高级查询示例

```csharp
public class AdvancedQueryExamples
{
    public static void RunExamples()
    {
        // 1. 日期时间索引的特殊查询
        var dateTimeIndex = TypedIndexManager.GetIndex(typeof(Order), "CreateTime") as DateTimeIndex;
        if (dateTimeIndex != null)
        {
            var thisYearOrders = dateTimeIndex.GetByYear(2024);
            var thisMonthOrders = dateTimeIndex.GetByYearMonth(2024, 12);
            var todayOrders = dateTimeIndex.GetByDate(2024, 12, 15);
        }
        
        // 2. 数值索引的精确范围控制
        var midRangeProducts = cdb.FindByRange<Product>("Price", 1000m, 5000m);
        
        // 3. 字符串索引的高级模式匹配
        var phoneProducts = cdb.FindByLike<Product>("Name", "手机*");      // 前缀
        var proProducts = cdb.FindByLike<Product>("Name", "*Pro");        // 后缀
        var smartProducts = cdb.FindByLike<Product>("Name", "*智能*");     // 包含
        var complexPattern = cdb.FindByLike<Product>("Code", "A*001");     // 复杂模式
        
        // 4. 布尔索引的多种表示
        var activeProducts1 = cdb.FindBy<Product>("IsActive", true);
        var activeProducts2 = cdb.FindBy<Product>("IsActive", "true");
        var activeProducts3 = cdb.FindBy<Product>("IsActive", 1);
        var activeProducts4 = cdb.FindBy<Product>("IsActive", "是");
    }
}
```

## 性能优化建议

### 1. 索引策略

```csharp
// ✅ 好的做法
public class OptimizedProduct : CacheObject
{
    [Indexed]
    public string Name { get; set; }           // 经常查询的字段

    [Indexed] 
    public decimal Price { get; set; }         // 支持范围查询

    [Indexed]
    public DateTime CreateTime { get; set; }   // 时间范围查询

    [NotIndexed("大文本")]
    public string Description { get; set; }    // 大文本不索引

    [NotSave]
    public string CachedHtml { get; set; }     // 临时数据不保存
}

// ❌ 需要优化的做法
public class UnoptimizedProduct : CacheObject
{
    public string Name { get; set; }           // 默认会建立索引
    public string LongDescription { get; set; } // 大文本也建立了索引，浪费内存
    public string InternalNotes { get; set; }  // 很少查询但建立了索引
}
```

### 2. 查询优化

```csharp
// ✅ 高效的查询
var results = cdb.FindByRange<Product>("Price", 1000m, 5000m);  // 直接范围查询

// ❌ 低效的查询
var allProducts = cdb.FindAll<Product>();
var filtered = allProducts.Where(p => p.Price >= 1000m && p.Price <= 5000m).ToList();

// ✅ 高效的复合查询
var conditions = new Dictionary<string, object> { { "CategoryId", 1 }, { "IsActive", true } };
var results = cdb.FindByMultiple<Product>(conditions);

// ❌ 低效的多次查询
var category1Products = cdb.FindBy<Product>("CategoryId", 1);
var activeProducts = category1Products.Where(p => p.IsActive).ToList();
```

### 3. 内存管理

```csharp
// 定期检查索引使用情况
var recommendations = IndexManager.RecommendIndexOptimization();
foreach (var rec in recommendations)
{
    if (rec.Priority == RecommendationPriority.High)
    {
        Console.WriteLine($"高优先级建议: {rec.PropertyName} - {rec.Recommendation}");
    }
}

// 清理未使用的索引（预览模式）
var cleanupResult = IndexManager.CleanupUnusedIndexes(dryRun: true);
if (cleanupResult.MemoryFreedMB > 10) // 如果能释放超过10MB
{
    Console.WriteLine($"建议清理未使用索引，可释放 {cleanupResult.MemoryFreedMB:F1} MB 内存");
}
```

## 迁移指南

### 从传统索引迁移

1. **无需修改现有代码** - 系统完全向后兼容
2. **启用类型感知索引** - 调用 `cdb.EnableTypedIndex(true)`
3. **逐步使用新API** - 在新功能中使用范围查询和模糊查询
4. **监控性能** - 使用 `IndexManager` 查看性能提升

### 性能测试

```csharp
public static void PerformanceTest()
{
    var stopwatch = Stopwatch.StartNew();
    
    // 测试范围查询性能
    var results = cdb.FindByRange<Product>("Price", 1000m, 5000m);
    
    stopwatch.Stop();
    Console.WriteLine($"范围查询耗时: {stopwatch.ElapsedMilliseconds} ms，结果数: {results.Count}");
}
```

## 最佳实践

1. **合理使用索引标记** - 只对经常查询的字段建立索引
2. **选择合适的查询方法** - 使用类型感知的查询获得最佳性能
3. **定期监控索引性能** - 使用索引管理工具优化性能
4. **及时清理无用索引** - 释放内存资源
5. **测试查询性能** - 在生产环境前进行充分测试

## 总结

数据类型感知索引系统为 Pek.MDB 带来了：

- **更高的查询性能** - 类型原生支持，避免类型转换开销
- **更丰富的查询功能** - 范围查询、模糊查询、复合查询
- **更好的内存效率** - 类型优化的数据结构
- **完全的向后兼容** - 现有代码无需修改
- **强大的监控工具** - 深入了解索引使用情况

通过合理使用这些新功能，您可以显著提升应用程序的查询性能和用户体验。
